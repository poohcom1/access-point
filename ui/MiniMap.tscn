[gd_scene load_steps=3 format=2]

[ext_resource path="res://assets/black.png" type="Texture" id=1]

[sub_resource type="GDScript" id=1]
script/source = "extends Control

var tilemap: TileMap
var scale: float
var offset: Vector2 # Offset to center the map. Set in _tilemap_init()

# Colors
export var PLAYER_COLOR: Color
export var STRUCTURE_COLOR: Color
export var RADAR_COLOR: Color
export var RADAR_PATH_COLOR: Color
export var ENEMY_COLOR: Color
export var TILECOLOR: Color

# Fields
const EPSILON = 0.00001

var radars := []

var radar_count = 0 # For caching purposes
var in_range_tiles = [] # For caching

func _ready():
	# Wait for all nodes to be ready
	yield(get_tree(), \"idle_frame\")
	
	tilemap = get_tree().get_nodes_in_group(\"tilemap\")[0]
	_tilemap_init()
	
	# Init radar tilemap positions
	radars = get_tree().get_nodes_in_group(\"radar\")
	radar_count = len(radars)
	
	for radar in radars:
		radar.tilemap_position = world_to_tilemap(radar.global_position)
	
func _tilemap_init():
	# Get size of tilemap
	var bounds: Rect2 = tilemap.get_used_rect()
	
	# Get scale and offset
	if bounds.size.x > bounds.size.y:
		print(\"Horizontal Map\")		
		scale = get_size().x / (bounds.size.x)
		offset = -get_size()/2 + Vector2(0, (get_size().y-bounds.size.y*scale) / 2)
	else:
		print(\"Vertical Map\")
		scale = get_size().y / (bounds.size.y)
		offset = -get_size()/2 + Vector2((get_size().x-bounds.size.x*scale) / 2, 0)
		
	# Alter offset if there are tiles coordinates in the negatives
	# to shift all tiles into the positive plane
	var min_neg_x = 0
	var min_neg_y = 0
	for cell in tilemap.get_used_cells():
		min_neg_x = min(cell.x, min_neg_x)
		min_neg_y = min(cell.y, min_neg_y)
		
	offset += Vector2(-min_neg_x, -min_neg_y) * scale


func _draw():
	if tilemap == null: return
	
	_draw_tilemap()
	_draw_objects()
	

\"\"\"
	Check if an object's tilemap position is in range of a radar
\"\"\"
func in_range(pos: Vector2) -> bool:
	var vision_objects = radars + [$\"/root/GameManager\".player]
	
	for obj in vision_objects:
		var tile_pos = (obj.tilemap_position if \"tilemap_position\" in obj else 
			world_to_tilemap(obj.global_position))
		# Squaring is faster than squareroot... so I assume this is more optimized
		if ( pos.distance_squared_to(tile_pos) 
				< obj.radar_range*obj.radar_range ) and obj.battery > EPSILON:
			return true
		
	return false
	
func _draw_objects():
	var objects = get_tree().get_nodes_in_group(\"map\")
	
	for object in objects:
		var tilemap_pos = world_to_tilemap(object.global_position)
		var pos = tilemap_to_minimap(tilemap_pos)
		if object is Player:
			draw_rect(Rect2(pos, Vector2.ONE * scale * 2), PLAYER_COLOR)
		elif in_range(tilemap_pos) or object.revealed:
			if object is Structure:
				if object in radars:
					draw_rect(Rect2(pos, Vector2.ONE * scale * 3), RADAR_COLOR)
					# Get waypoints
					for next in object.next_radars:
						var next_radar = object.get_node(next)
						if next_radar.revealed:
							var next_pos = tilemap_to_minimap(world_to_tilemap(next_radar.global_position))
							draw_line(pos + Vector2.ONE * scale * 1.5, next_pos + Vector2.ONE * scale * 1.5, RADAR_PATH_COLOR, 1)
				else:
					draw_rect(Rect2(pos, Vector2.ONE * scale * 2), STRUCTURE_COLOR)
			elif object is Enemy:
				draw_rect(Rect2(pos, Vector2.ONE * scale), ENEMY_COLOR)


func _draw_tilemap():
	draw_set_transform(rect_size / 2, 0, Vector2.ONE)
	
	# Find all tiles that has collision
	for tile in tilemap.tile_set.get_tiles_ids():

		# This assumes that tiles have a single collision shape
		if tilemap.tile_set.tile_get_shape(tile, 0) != null:
			var color = TILECOLOR
			var cells = tilemap.get_used_cells_by_id(tile)
			for cell in cells:
				if in_range(cell):
					draw_rect(Rect2(tilemap_to_minimap(cell), Vector2.ONE * scale), color)

func _process(_delta):
	update()
	
	
func world_to_tilemap(position: Vector2) -> Vector2:
	return tilemap.world_to_map(tilemap.to_local(position))

func tilemap_to_minimap(position: Vector2) -> Vector2:
	return position * scale + offset
"

[node name="MiniMap" type="MarginContainer"]
anchor_right = 1.0
anchor_bottom = 1.0
margin_right = -825.0
margin_bottom = -416.0
__meta__ = {
"_edit_use_anchors_": false
}

[node name="Grid" type="MarginContainer" parent="."]
margin_right = 199.0
margin_bottom = 184.0

[node name="TextureRect" type="TextureRect" parent="Grid"]
margin_right = 199.0
margin_bottom = 184.0
texture = ExtResource( 1 )
stretch_mode = 2

[node name="Map" type="Control" parent="Grid"]
margin_right = 199.0
margin_bottom = 184.0
script = SubResource( 1 )
__meta__ = {
"_edit_use_anchors_": false
}
PLAYER_COLOR = Color( 1, 1, 1, 1 )
STRUCTURE_COLOR = Color( 0, 0.741176, 1, 1 )
RADAR_COLOR = Color( 0.917647, 0.901961, 0.486275, 1 )
RADAR_PATH_COLOR = Color( 0.980392, 0.996078, 0.768627, 1 )
ENEMY_COLOR = Color( 0.921569, 0.0862745, 0.0862745, 1 )
TILECOLOR = Color( 0.184314, 0.184314, 0.184314, 1 )
